<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Inspiration Clock</title>
<style>
  :root { --bg: url("%%IMAGE_URL%%"); }
  html, body { height: 100%; }
  body {
    margin: 0; overflow: hidden; background: #111; color: #fff;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
  }
  body::before {
    content: ""; position: fixed; inset: 0; z-index: 0;
    background-image: var(--bg); background-position: center; background-size: cover;
    filter: blur(24px) brightness(0.9); transform: scale(1.1);
  }
  .wallpaper {
    position: fixed; inset: 0; z-index: 1;
    background-image: var(--bg); background-repeat: no-repeat;
    background-position: center; background-size: contain;
  }

  .clock {
    position: fixed;
    top: 33%;                 /* ~1/3 down the viewport */
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2;

    display: inline-block;
    width: min(80vw, var(--img-w, 100vw));  /* 0.8 screen but not beyond visible image */
    text-align: center;

    /* remove shaded box */
    background: none;
    backdrop-filter: none;
    border-radius: 0;
    padding: 0;
  }

  .adbar {
    position: fixed;
    left: 50%;
    bottom: 20px;                  /* distance from bottom edge */
    transform: translateX(-50%);   /* centers horizontally */
    z-index: 4;                    /* above wallpaper (z:1), clock (z:2), fs-btn (z:3) */
  
    text-align: center;
  }
  
  .adbar a {
    display: inline-block;
    padding: 10px 14px;
    border-radius: 8px;
    background: #ffdd00;
    color: #000;
    font-weight: 700;
    text-decoration: none;
    font-family: inherit;
  }

  #clock-time {
    display: block;
    width: 100%;
    font-variant-numeric: tabular-nums;
    font-weight: 700;
    letter-spacing: .04em;
    line-height: 1.1;
    color: #fff;

    /* text outline */
    text-shadow:
      -3px -3px 0 #000,
       3px -3px 0 #000,
      -3px  3px 0 #000,
       3px  3px 0 #000;

    /* base font scaling — JS fitText will fine-tune */
    font-size: clamp(48px, 8vw, 220px);
  }

  #clock-date {
    display: block;
    margin-top: 0.25em;
    font-weight: 500;
    opacity: 0.9;
    color: #fff;

    /* thinner outline */
    text-shadow:
      -2px -2px 0 #000,
       2px -2px 0 #000,
      -2px  2px 0 #000,
       2px  2px 0 #000;

    font-size: 0.45em; /* relative to time */
  }

    /* Controls container: bottom-left & bottom-right with space between */
  #controls {
    position: fixed;
    bottom: 20px;
    left: 20px;
    right: 20px;
    display: flex;
    justify-content: space-between;   /* info left, fullscreen right */
    z-index: 3;
    opacity: 1;
    transition: opacity 0.5s ease;
  }
  #controls.hidden {
    opacity: 0;
    pointer-events: none;
  }
  
  /* Shared button style */
  #controls button {
    background: rgba(0,0,0,0.4);
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 10px 14px;
    font-size: 20px;
    cursor: pointer;
    backdrop-filter: blur(6px);
    transition: background 0.2s ease;
  }
  #controls button:hover {
    background: rgba(0,0,0,0.65);
  }
  
  /* overlay panel */
  #info-panel {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    color: #fff;
    display: none;          /* hidden by default */
    align-items: center;
    justify-content: center;
    text-align: center;
    padding: 30px;
    z-index: 10;
  }
  #info-panel.active {
    display: flex;
  }
  #info-panel .content {
    max-width: 600px;
    background: rgba(0,0,0,0.6);
    padding: 20px;
    border-radius: 12px;
    line-height: 1.5;
    font-size: 18px;
  }
  #info-panel button {
    margin-top: 20px;
    padding: 8px 16px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background: #ffdd00;
    color: #000;
    font-weight: 700;
  }
</style>
</head>
<body>
  <div class="wallpaper" role="img" aria-label="Inspirational wallpaper"></div>
  <div class="clock">
    <div id="clock-time">--:--</div>
    <div id="clock-date" style="font-size: 0.45em; font-weight: 500; opacity: 0.9;">—</div>
  </div>
  <div id="controls">
    <button id="info-btn" title="Info">ℹ️</button>
    <button id="fs-btn" title="Fullscreen">⛶</button>
  </div>

  <div id="info-panel">
    <div class="content">
      <h2>About This Page</h2>
      <p>
        This Inspiration Clock shows the current time and date over a daily-changing
        inspirational wallpaper. The background updates automatically every day at around 6AM PDT with a new AI-generated design.
      </p>
      <p>
        Use the fullscreen button for a clean display, and the wake-lock feature will
        keep your screen from sleeping while the clock is open.
      </p>
      <button id="info-close">Close</button>
    </div>
  </div>
    
  <div class="adbar">
    <a href="https://www.buymeacoffee.com/wilomocha" target="_blank" rel="noopener">
      ☕ Buy me a coffee
    </a>
  </div>
</div>


<script>
  const WEEKDAYS = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];
  const MONTHS = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];

  function pad2(n){ return String(n).padStart(2,"0"); }

  function tick(){
    const d = new Date();

    // Time (HH:MM AM/PM)
    let hours = d.getHours();
    const minutes = pad2(d.getMinutes());
    const ampm = hours >= 12 ? "PM" : "AM";
    hours = hours % 12;
    if (hours === 0) hours = 12;
    document.getElementById("clock-time").textContent = `${hours}:${minutes} ${ampm}`;

    // Date (Weekday, Mon DD)
    const weekday = WEEKDAYS[d.getDay()];
    const mon = MONTHS[d.getMonth()];
    const day = d.getDate();
    document.getElementById("clock-date").textContent = `${weekday}, ${mon} ${day}`;
  }

  tick();
  setInterval(tick, 15 * 1000);


  // --- Wake Lock to prevent screen sleep ---
  let wakeLock = null;
  async function requestWakeLock() {
    try {
      if ('wakeLock' in navigator) {
        wakeLock = await navigator.wakeLock.request('screen');
        console.log("[WakeLock] Screen lock acquired");
        wakeLock.addEventListener('release', () => {
          console.log('[WakeLock] Screen lock released');
        });
      } else {
        console.log("[WakeLock] API not supported in this browser");
      }
    } catch (err) {
      console.error(`[WakeLock] Error: ${err.name}, ${err.message}`);
    }
  }
  requestWakeLock();

  // Re-request on visibility change
  document.addEventListener('visibilitychange', () => {
    if (wakeLock !== null && document.visibilityState === 'visible') {
      requestWakeLock();
    }
  }); // <-- was missing

  // --- Fullscreen toggle ---
  const fsBtn = document.getElementById("fs-btn");

  async function toggleFullscreen() {
    if (!document.fullscreenElement) {
      try {
        await document.documentElement.requestFullscreen();
        fsBtn.textContent = "⤫";
      } catch (err) {
        console.error("[Fullscreen] Error:", err);
      }
    } else {
      try {
        await document.exitFullscreen();
        fsBtn.textContent = "⛶";
      } catch (err) {
        console.error("[Fullscreen] Error:", err);
      }
    }
  }
  fsBtn.addEventListener("click", toggleFullscreen);

  // Update button icon when user exits via Esc
  document.addEventListener("fullscreenchange", () => {
    if (!document.fullscreenElement) {
      fsBtn.textContent = "⛶";
    }
  }); 

// --- Auto-hide controls (info + fullscreen) after inactivity ---
let controlsHideTimeout;
const controls = document.getElementById("controls");

function showControls() {
  controls.classList.remove("hidden");
  clearTimeout(controlsHideTimeout);
  controlsHideTimeout = setTimeout(() => {
    controls.classList.add("hidden");
  }, 3000); // hide after 3s of no input
}

// Count user activity
["mousemove","keydown","touchstart"].forEach(evt => {
  document.addEventListener(evt, showControls, { passive: true });
});

// Start hidden on load; show once to hint controls
controls.classList.add("hidden");
setTimeout(showControls, 300); // brief reveal after load

  // --- Info button toggle ---
const infoBtn = document.getElementById("info-btn");
const infoPanel = document.getElementById("info-panel");
const infoClose = document.getElementById("info-close");

infoBtn.addEventListener("click", () => {
  infoPanel.classList.add("active");
});

infoClose.addEventListener("click", () => {
  infoPanel.classList.remove("active");
});

// also close if you click outside content
infoPanel.addEventListener("click", (e) => {
  if (e.target === infoPanel) {
    infoPanel.classList.remove("active");
  }
});

  // --- helper you already added (leave as-is if present) ---
  function extractBgUrl(str){ const m = str.match(/url\((['"]?)(.*?)\1\)/i); return m ? m[2] : null; }
  function computeContainWidth(vw, vh, imgW, imgH){ const s = Math.min(vw/imgW, vh/imgH); return imgW * s; }

  async function setClockMaxWidthFromImage(){
    try {
      const wp = document.querySelector('.wallpaper');
      if (!wp) return;
      const style = getComputedStyle(wp);
      const bgUrl = extractBgUrl(style.backgroundImage);
      if (!bgUrl) return;

      const img = new Image();
      img.decoding = 'async';
      img.src = bgUrl;
      await (img.complete ? Promise.resolve() : new Promise((res, rej)=>{ img.onload=res; img.onerror=rej; }));

      const vw = window.innerWidth, vh = window.innerHeight;
      const dispW = computeContainWidth(vw, vh, img.naturalWidth, img.naturalHeight);
      document.documentElement.style.setProperty('--img-w', dispW + 'px');
    } catch (e) {
      console.warn('[clock-width]', e);
    }
  }

  // --- NEW: fit the time text to the clock box width ---
  function fitClockText(){
    const clock = document.querySelector('.clock');
    const timeEl = document.getElementById('clock-time');
    const dateEl = document.getElementById('clock-date');
    if (!clock || !timeEl || !dateEl) return;

    // Target: make the time line fill the inner width of the .clock box.
    // 1) get available inner width (minus padding)
    const cs = getComputedStyle(clock);
    const padX = parseFloat(cs.paddingLeft) + parseFloat(cs.paddingRight);
    const targetW = (clock.getBoundingClientRect().width - padX) * 0.98;


    // 2) Measure current width at a known font size (100px), then scale.
    // (Tabular numerals help keep width predictable.)
    const oldSize = timeEl.style.fontSize;
    timeEl.style.fontSize = '100px';
    // Force reflow so scrollWidth is accurate
    const measured = timeEl.scrollWidth || timeEl.getBoundingClientRect().width || 1;
    const scale = targetW / measured;

    // 3) Apply scaled size; cap for safety
    const newPx = Math.min(220, Math.max(16, 100 * scale));
    timeEl.style.fontSize = newPx + 'px';

    // 4) Date follows proportionally
    dateEl.style.fontSize = Math.max(12, Math.round(newPx * 0.42)) + 'px';

    // restore (not strictly needed since we overwrote)
    // timeEl.style.fontSize = newPx + 'px';
  }

  // Call this whenever layout could change
  function relayout(){
    setClockMaxWidthFromImage().then(fitClockText).catch(()=>fitClockText());
  }

  // Initial
  relayout();

  // Re-run on resize/orientation changes
  addEventListener('resize', relayout);
  addEventListener('orientationchange', relayout);

  // Also re-fit right after tick(), because “9:08 AM” → “10:08 AM” changes width
  const _oldTick = tick;
  window.tick = function(){
    _oldTick();
    // Queue after DOM updates
    requestAnimationFrame(fitClockText);
  };

// --- Reload at 00:00 / 06:00 / 12:00 / 18:00 local time ---
let reloadTimer;

function msUntilNextBoundary() {
  const now = new Date();
  const boundaries = [0, 6, 12, 18]; // hours
  const nextHour = boundaries.find(h => h > now.getHours());
  // target today at nextHour, else tomorrow at 00:00
  const target = nextHour !== undefined
    ? new Date(now.getFullYear(), now.getMonth(), now.getDate(), nextHour, 0, 5)
    : new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 0, 0, 5);

  return Math.max(1000, target - now); // at least 1s
}

function scheduleReload6h() {
  clearTimeout(reloadTimer);
  const delay = msUntilNextBoundary();
  // (Optional) console.log("Reloading in", Math.round(delay/1000/60), "min");
  reloadTimer = setTimeout(() => location.reload(), delay);
}

// start the schedule
scheduleReload6h();

// If the tab was hidden/asleep, re-schedule on return
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    scheduleReload6h();
  }
});

</script>

</body>
</html>
